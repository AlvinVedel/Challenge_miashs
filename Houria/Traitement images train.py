# -*- coding: utf-8 -*-
"""Traitement des images du train.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lYRDiCNxIad8rnsuciKSZIdwKxnazAAJ

# Chargement et dézip des données
"""

from google.colab import drive
drive.mount('/content/drive', force_remount=True)

import zipfile
import os

zip_file_path = '/content/drive/My Drive/Challenge DEEP/data.zip'
extracted_folder_path = '/content/drive/My Drive/Challenge DEEP/data/'

with zipfile.ZipFile(zip_file_path, 'r') as zip_ref:
    zip_ref.extractall(extracted_folder_path)

"""# Traitement des images et des labels"""

import os
import numpy as np
from PIL import Image
import matplotlib.pyplot as plt
import pandas as pd

extracted_files = os.listdir('/content/drive/My Drive/Challenge DEEP/data/data')
print(extracted_files)

folder_path = "/content/drive/My Drive/Challenge DEEP/data/data/"
txt_files = [f for f in os.listdir(folder_path) if f.endswith('.txt')]
print(len(txt_files))

file_names = []
labels = []
project = []
x = []
y = []
h = []
w = []

for m in range(len(txt_files)):
    with open(folder_path + txt_files[m], 'r', encoding='utf-8') as file:
        for line in file:
            values = line.strip().split()  # Séparer par espace
            file_names.append(txt_files[m])
            all_labels = values[0].strip().split("_")
            labels.append([float(all_labels[j]) for j in range(4)])
            project_name = ""
            for k in range(1, len(values) - 4):
                project_name += values[k] + " "
            project.append(project_name.strip())

            project.append(values[1])
            x.append(float(values[-4]))
            y.append(float(values[-3]))
            w.append(float(values[-2]))
            h.append(float(values[-1]))

dimensions1 = []
dimensions2 = []

labels_dict = {"label1":[], "label2":[], "label3":[], "label4":[], "project": [], "img_name":[], "id":[]}
image_save_folder = "/content/drive/My Drive/Challenge DEEP/data/crops/raw_crops/"

for i, txt_file in enumerate(file_names):
    print(i)
    name = "crop_" + str(i + 1)
    image_file = txt_file.replace('.txt', '.jpg')
    image_path = os.path.join(folder_path, image_file)
    image = Image.open(image_path)
    image_np = np.array(image)

    img_height, img_width = image_np.shape[:2]

    xcentre = int(x[i] * img_width)
    ycentre = int(y[i] * img_height)
    largeur = int(w[i] * img_width)
    hauteur = int(h[i] * img_height)

    xmin = int(xcentre - largeur // 2)
    xmax = int(xmin + largeur)
    ymin = int(ycentre - hauteur // 2)
    ymax = int(ymin + hauteur)

    dimensions1.append(xmax - xmin)
    dimensions2.append(ymax - ymin)

    cropped_image = image_np[ymin:ymax, xmin:xmax]
    if cropped_image.shape[0] == 0 or cropped_image.shape[1] == 0:
        print(f"Image {name} est vide après découpe, saut de la sauvegarde.")
        continue

    cropped_image_pil = Image.fromarray(cropped_image)
    cropped_image_pil.save(os.path.join(image_save_folder, name + ".jpg"))

    labels_dict["label1"].append(labels[i][0])
    labels_dict["label2"].append(labels[i][1])
    labels_dict["label3"].append(labels[i][2])
    labels_dict["label4"].append(labels[i][3])
    labels_dict["project"].append(project[i])
    labels_dict["id"].append(txt_file[:-4])
    labels_dict["img_name"].append(name + ".jpg")

labels_df = pd.DataFrame(labels_dict)
labels_df.to_csv(os.path.join(image_save_folder, 'labels.csv'), index=False)

df = pd.read_csv('/content/drive/My Drive/Challenge DEEP/data/crops/raw_crops/labels.csv')
df

X_train = []
Y_train = []

folder_path = '/content/drive/MyDrive/Challenge DEEP/data/crops/raw_crops/'

for index, row in df.iterrows():
    image_name = row['img_name']
    labels = [row['label1'], row['label2'], row['label3'], row['label4']]

    image_path = os.path.join(folder_path, image_name)
    image = Image.open(image_path)
    image_np = np.array(image)

    for i, label in enumerate(labels):
        X_train.append(image_np)
        Y_train.append(int(label))

print(len(X_train))

"""On lui donne les 4 labels, c'est comme s'il faisait 4 époques en 1. Il faudra le pénaliser plus pendant la mise à jour lorsqu'il penche souvent pour la majorité alors qu'elle s'est trompée."""

import matplotlib.pyplot as plt

random_image = X_train[987]
random_label = Y_train[1]

plt.imshow(random_image)
plt.title(f'Label: {random_label}')
plt.axis('off')
plt.show()

print(len(X_train), len(Y_train))